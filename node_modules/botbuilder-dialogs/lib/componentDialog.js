"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dialog_1 = require("./dialog");
const dialogContext_1 = require("./dialogContext");
const dialogSet_1 = require("./dialogSet");
const PERSISTED_DIALOG_STATE = 'dialogs';
/**
 * The `ComponentDialog` class lets you break your bots logic up into components that can be added
 * as a dialog to other dialog sets within your bots project or exported and used in other bot
 * projects.
 * @param O (Optional) options that can be passed into the begin() method.
 */
class ComponentDialog extends dialog_1.Dialog {
    constructor() {
        super(...arguments);
        this.dialogs = new dialogSet_1.DialogSet(null);
    }
    beginDialog(outerDC, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Start the inner dialog.
            const dialogState = { dialogStack: [] };
            outerDC.activeDialog.state[PERSISTED_DIALOG_STATE] = dialogState;
            const innerDC = new dialogContext_1.DialogContext(this.dialogs, outerDC.context, dialogState);
            const turnResult = yield this.onBeginDialog(innerDC, options);
            // Check for end of inner dialog
            if (turnResult.status !== dialog_1.DialogTurnStatus.waiting) {
                // Return result to calling dialog
                return yield this.endComponent(outerDC, turnResult.result);
            }
            else {
                // Just signal end of turn
                return dialog_1.Dialog.EndOfTurn;
            }
        });
    }
    continueDialog(outerDC) {
        return __awaiter(this, void 0, void 0, function* () {
            // Continue execution of inner dialog.
            const dialogState = outerDC.activeDialog.state[PERSISTED_DIALOG_STATE];
            const innerDC = new dialogContext_1.DialogContext(this.dialogs, outerDC.context, dialogState);
            const turnResult = yield this.onContinueDialog(innerDC);
            // Check for end of inner dialog
            if (turnResult.status !== dialog_1.DialogTurnStatus.waiting) {
                // Return result to calling dialog
                return yield this.endComponent(outerDC, turnResult.result);
            }
            else {
                // Just signal end of turn
                return dialog_1.Dialog.EndOfTurn;
            }
        });
    }
    resumeDialog(dc, reason, result) {
        return __awaiter(this, void 0, void 0, function* () {
            // Containers are typically leaf nodes on the stack but the dev is free to push other dialogs
            // on top of the stack which will result in the container receiving an unexpected call to
            // resumeDialog() when the pushed on dialog ends.
            // To avoid the container prematurely ending we need to implement this method and simply
            // ask our inner dialog stack to re-prompt.
            yield this.repromptDialog(dc.context, dc.activeDialog);
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    repromptDialog(context, instance) {
        return __awaiter(this, void 0, void 0, function* () {
            // Forward to inner dialogs
            const dialogState = instance.state[PERSISTED_DIALOG_STATE];
            const innerDC = new dialogContext_1.DialogContext(this.dialogs, context, dialogState);
            yield innerDC.repromptDialog();
            // Notify component.
            yield this.onRepromptDialog(context, instance);
        });
    }
    endDialog(context, instance, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            // Forward cancel to inner dialogs
            if (reason === dialog_1.DialogReason.cancelCalled) {
                const dialogState = instance.state[PERSISTED_DIALOG_STATE];
                const innerDC = new dialogContext_1.DialogContext(this.dialogs, context, dialogState);
                yield innerDC.cancelAllDialogs();
            }
            // Notify component
            yield this.onEndDialog(context, instance, reason);
        });
    }
    addDialog(dialog) {
        this.dialogs.add(dialog);
        if (this.initialDialogId === undefined) {
            this.initialDialogId = dialog.id;
        }
        return this;
    }
    /**
     * Finds a dialog that was previously added to the set using [add()](#add).
     *
     * @remarks
     * This example finds a dialog named "greeting":
     *
     * ```JavaScript
     * const dialog = dialogs.find('greeting');
     * ```
     * @param dialogId ID of the dialog/prompt to lookup.
     */
    findDialog(dialogId) {
        return this.dialogs.find(dialogId);
    }
    onBeginDialog(innerDC, options) {
        return innerDC.beginDialog(this.initialDialogId, options);
    }
    onContinueDialog(innerDC) {
        return innerDC.continueDialog();
    }
    onEndDialog(context, instance, reason) {
        return Promise.resolve();
    }
    onRepromptDialog(context, instance) {
        return Promise.resolve();
    }
    endComponent(outerDC, result) {
        return outerDC.endDialog(result);
    }
}
exports.ComponentDialog = ComponentDialog;
//# sourceMappingURL=componentDialog.js.map